/** @file
    @brief Implementation of tool to install a self-signed USB CDC driver
        selectively on old VID/PID pairs, only if they meet certain criteria.

    @date 2015

    @author
    Sensics, Inc.
    <http://sensics.com/osvr>
*/

// Copyright 2015 Sensics, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Internal Includes
// - none

// Library/third-party includes
#include "libwdi.h"

// Standard includes
#include <stdio.h>
#include <string.h>
#include <stdint.h>

#include <string>
#include <iostream>
#include <algorithm>

struct OverrideDevice {
  /// vendor ID
  const uint16_t vid;
  /// product ID
  const uint16_t pid;
  /// Device description prefix - typically something like the "bus reported
  /// device description" in the 8.1 device manager.
  const std::string deviceDescPrefix;
  /// Predicate to compare this override entry with a libwdi device struct
  /// (comparing vid, pid, and a prefix of the device description)
  bool checkAgainst(struct wdi_device_info const &dev) const {
    bool ret = false;
    if (vid != dev.vid || pid != dev.pid) {
      // VID or PID not a match
      return ret;
    }
    if (std::strlen(dev.desc) < deviceDescPrefix.length()) {
      // Description prefix can't possibly match, too short.
      return ret;
    }
    if (0 !=
        deviceDescPrefix.compare(0, std::string::npos, deviceDescPrefix,
                                 deviceDescPrefix.length())) {
      // Doesn't start with the device desc prefix
      return ret;
    }
    ret = true;
    return ret;
  }
};

/// All overrides that will trigger a CDC install, can add more to this array.
static const auto OVERRIDES = {OverrideDevice{0x03EB, 0x2421, "OSVR"}};

static const char INF[] = "sensics_generic_cdc.inf";

// ugh, dislike defines, but the wdi_options_prepare_driver wants char *, not
// const char *
#define VENDOR "Sensics, Inc.";
#define CERT_SUBJECT "CN=USB CDC (libwdi autogenerated)";

int main() {

  wdi_set_log_level(WDI_LOG_LEVEL_ERROR);

  std::size_t driverlessFound = 0;
  std::size_t matchingFound = 0;
  std::size_t successes = 0;
  struct wdi_device_info *list = nullptr;
  if (wdi_create_list(&list, nullptr) == WDI_SUCCESS) {
    for (struct wdi_device_info *device = list; device != nullptr;
         device = device->next) {
      printf("Found driverless USB device: \"%s\" (%04X:%04X)\n", device->desc,
             device->vid, device->pid);
      driverlessFound++;

      // Check to see if we are OK to install a driver for this device.
      auto doesThisOverrideMatch = [&](OverrideDevice const & override) {
        return override.checkAgainst(*device);
      };
      auto doesNoOverrideMatch = [&] {
        return std::none_of(begin(OVERRIDES), end(OVERRIDES),
                            doesThisOverrideMatch);
      };
      if (doesNoOverrideMatch()) {
        // None of the override entries match this device, keep going.
        continue;
      }
      // OK, passed the hurdles!
      printf(" - Eligible for update!\n");
      matchingFound++;
      {
        char vendor[] = VENDOR;
        char cert_subject[] = CERT_SUBJECT;
        wdi_options_prepare_driver opts = {0};
        opts.driver_type = WDI_CDC;
        opts.vendor_name = vendor;
        opts.disable_cat = FALSE;
        opts.disable_signing = FALSE;
        opts.cert_subject = cert_subject;
        opts.use_wcid_driver = FALSE;
        int result = wdi_prepare_driver(device, nullptr, INF, &opts);
        if (WDI_SUCCESS == result) {
          printf(" - Driver preparation succeeded!\n");
        } else {
          printf(" - Driver preparation failed: %s\n", wdi_strerror(result));
          printf("   Skipping this device.\n");
          continue;
        }
      }
      {
        int result = wdi_install_driver(device, nullptr, INF, nullptr);
        if (WDI_SUCCESS == result) {
          printf(" - Driver install succeeded!\n");
          successes++;
        } else {
          printf(" - Driver install failed: %s\n", wdi_strerror(result));
        }
      }
    }
    wdi_destroy_list(list);
  }

  /// Output a summary
  std::cout << "\nSummary:\n" << driverlessFound
            << " driverless USB devices found." << std::endl;
  std::cout << matchingFound << " matched our search criteria." << std::endl;
  if (matchingFound > 0) {
    if (successes == matchingFound) {
      std::cout << "Driver install for all matches completed successfully."
                << std::endl;
    } else {
      std::cout << successes << " device driver installs succeeded."
                << std::endl;
    }

    std::cout << "Press enter to exit..." << std::endl;
    std::cin.ignore();
  }
  return (successes == matchingFound) ? 0 : -1;
}
