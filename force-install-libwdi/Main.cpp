/** @file
    @brief Implementation of tool to install a self-signed USB CDC driver
        selectively on old VID/PID pairs, only if they meet certain criteria.

    @date 2015

    @author
    Sensics, Inc.
    <http://sensics.com/osvr>
*/

// Copyright 2015 Sensics, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Internal Includes
// - none

// Library/third-party includes
#include "libwdi.h"

// Standard includes
#include <stdio.h>
#include <string.h>
#include <stdint.h>

#include <string>
#include <iostream>
#include <algorithm>

/// An entry specifying a device that we'll install a CDC driver for.
struct OverrideDevice {
  /// vendor ID
  const uint16_t vid;
  /// product ID
  const uint16_t pid;
  /// Device description prefix - typically something like the "bus reported
  /// device description" in the 8.1 device manager.
  const std::string deviceDescPrefix;
  /// Predicate to compare this override entry with a libwdi device struct
  /// (comparing vid, pid, and a prefix of the device description)
  bool checkAgainst(struct wdi_device_info const &dev) const {
    bool ret = false;
    if (vid != dev.vid || pid != dev.pid) {
      // VID or PID not a match
      return ret;
    }
    if (std::strlen(dev.desc) < deviceDescPrefix.length()) {
      // Description prefix can't possibly match, too short.
      return ret;
    }
    if (0 !=
        deviceDescPrefix.compare(0, std::string::npos, deviceDescPrefix,
                                 deviceDescPrefix.length())) {
      // Doesn't start with the device desc prefix
      return ret;
    }
    ret = true;
    return ret;
  }
};

/// Array of overrides that will trigger a CDC install (can add more).
static const auto OVERRIDES = {
    OverrideDevice{0x03EB, 0x2421, "OSVR"},
    OverrideDevice{0x03EB, 0x0678, "Sensics Emulated Device"}};

/// The inf file name to generate.
static const char INF[] = "sensics_generic_cdc.inf";

// ugh, dislike defines, but the wdi_options_prepare_driver wants char *, not
// const char *
#define VENDOR "Sensics, Inc.";
#define CERT_SUBJECT "CN=USB CDC (libwdi autogenerated)";

/// Return struct from tryInstall with detailed device counts
struct Results {
  std::size_t driverlessFound = 0;
  std::size_t matchingFound = 0;
  std::size_t successes = 0;
};

/// Try installing the driver for all devices that lack drivers and match
/// something in our list of overrides. Extract location is the temp directory
/// if null.
static Results tryInstall(const char *extractLocation = nullptr) {
  Results ret;

  /// Create enumerator
  struct wdi_device_info *list = nullptr;
  int result = wdi_create_list(&list, nullptr);
  if (result != WDI_SUCCESS) {
    throw std::runtime_error(
        std::string("libwdi could not create a device list:") +
        wdi_strerror(result));
  }

  /// Iterate through all USB devices without drivers
  for (struct wdi_device_info *device = list; device != nullptr;
       device = device->next) {
    printf("Found driverless USB device: \"%s\" (%04X:%04X)\n", device->desc,
           device->vid, device->pid);
    ret.driverlessFound++;

    // Check to see if we are OK to install a driver for this device.
    auto doesThisOverrideMatch = [&](OverrideDevice const & override) {
      return override.checkAgainst(*device);
    };
    auto doesNoOverrideMatch = [&] {
      return std::none_of(begin(OVERRIDES), end(OVERRIDES),
                          doesThisOverrideMatch);
    };
    if (doesNoOverrideMatch()) {
      // None of the override entries match this device, keep going.
      continue;
    }

    // OK, passed the hurdles!
    printf(" - Eligible for update!\n");
    ret.matchingFound++;
    {
      /// Set up structure for "prepare driver" (extract/generate/sign) step
      char vendor[] = VENDOR;
      char cert_subject[] = CERT_SUBJECT;
      wdi_options_prepare_driver opts = {0};
      opts.driver_type = WDI_CDC;
      opts.vendor_name = vendor;
      opts.disable_cat = FALSE;
      opts.disable_signing = FALSE;
      opts.cert_subject = cert_subject;
      opts.use_wcid_driver = FALSE;
      /// Perform "prepare driver"
      int result = wdi_prepare_driver(device, extractLocation, INF, &opts);
      if (WDI_SUCCESS == result) {
        printf(" - Driver preparation succeeded!\n");
      } else {
        printf(" - Driver preparation failed: %s\n", wdi_strerror(result));
        printf("   Skipping this device.\n");
        continue;
      }
    }
    {
      /// Perform "install driver"
      int result = wdi_install_driver(device, extractLocation, INF, nullptr);
      if (WDI_SUCCESS == result) {
        printf(" - Driver install succeeded!\n");
        ret.successes++;
      } else {
        printf(" - Driver install failed: %s\n", wdi_strerror(result));
      }
    }
  }
  wdi_destroy_list(list);
  return ret;
}

/// Output a summary
static void output(Results const &results) {
  std::cout << "\nSummary:\n" << results.driverlessFound
            << " driverless USB devices found." << std::endl;
  std::cout << results.matchingFound << " matched our search criteria."
            << std::endl;
  if (results.matchingFound > 0) {
    if (results.successes == results.matchingFound) {
      std::cout << "Driver install for all matches completed successfully."
                << std::endl;
    } else {
      std::cout << results.successes << " device driver installs succeeded."
                << std::endl;
    }
  }
}

static const int EXCEPTION_EXIT_CODE = -2;
static const int NOT_ALL_SUCCESSES_EXIT_CODE = -1;

int main(int argc, char *argv[]) {
  wdi_set_log_level(WDI_LOG_LEVEL_ERROR);
  Results results;
  try {
    results = tryInstall();
  } catch (std::exception const &e) {
    std::cerr << "Caught exception: " << e.what() << std::endl;
    return EXCEPTION_EXIT_CODE;
  }
  output(results);
  if (results.matchingFound > 0 && 0 == results.successes) {
    std::cerr << "Group Policy (most common in large organizations) might be "
                 "blocking the execution of the embedded install tools from a "
                 "temp directory. Trying again, extracting to the current "
                 "working directory instead."
              << std::endl;
    try {
      results = tryInstall(".");
    } catch (std::exception const &e) {
      std::cerr << "Caught exception: " << e.what() << std::endl;
      return EXCEPTION_EXIT_CODE;
    }
    output(results);
  }

  if (results.matchingFound > 0) {
    std::cout << "Press enter to exit..." << std::endl;
    std::cin.ignore();
  }
  return (results.successes == results.matchingFound)
             ? 0
             : NOT_ALL_SUCCESSES_EXIT_CODE;
}
